<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Plugins</title>

  <section>
    <title>O que exatamente é um plugin?</title>

    <para>Um plugin do jQuery é simplesmente um novo método que nós usamos
    para extender o protótipo de objeto do jQuery. Através da extensão do
    protótipo, você permite que todos os objetos do jQuery herdem quaisquer
    métodos que você adicionar. Como estabelecido, sempre que você chama 
    <code>jQuery()</code> você está criando um novo objeto do jQuery, com
    todos os métodos herdados.</para>

    <para>A idéia de um plugin é fazer alguma coisa com uma coleção de elementos.
    Você pode considerar que cada método que vem com o core do jQuery seja um
    plugin, como <code>fadeOut</code> ou <code>addClass</code>.</para>

    <para>Você pode fazer seus próprios plugins e usa-los privadamente no seu
    código ou você pode libera-lo para comunidade. Há milhares de plugins para
    o jQuery disponíveis online. A barreira para criar um plugin próprio é tão
    pequena que você desejará fazer um logo "de cara"!</para>
  </section>

  <section>
    <title>Como criar um plugin básico</title>

    <para>A notação para criar um novo plugin é a seguinte:</para>

    <programlisting>(function($){
    $.fn.myNewPlugin = function() {
        return this.each(function(){
            // faz alguma coisa
        });
    };
}(jQuery));</programlisting>

    <para>Mas não se deixe confundir. O objetivo de um plugin do jQuery é 
    extender o protótipo do objeto do jQuery, e isso é o que está acontecendo
    nesta linha:</para>

    <programlisting>$.fn.myNewPlugin = function() { //...</programlisting>

    <para>Nós encapsulamos esta associação numa função imediatamente invocada:</para>

    <programlisting>(function($){
    //...
}(jQuery));</programlisting>

    <para>Isso possui o efeito de criar um escopo "privado" que nos permite 
    extender o jQuery usando o símbolo de dólar sem ter o risco de ter o dólar
    sobrescrito por outra biblioteca.</para>

    <para>Então nosso verdadeiro plugin, até agora, é este:</para>

    <programlisting>$.fn.myNewPlugin = function() {
    return this.each(function(){
        // faz alguma coisa
    });
};</programlisting>

    <para>A palavra chave <code>this</code> dentro do novo plugin refere-se 
    ao objeto jQuery em que o plugin está sendo chamado.</para>

    <programlisting>var somejQueryObject = $('#something');

$.fn.myNewPlugin = function() {
    alert(this === somejQueryObject);
};

somejQueryObject.myNewPlugin(); // alerta 'true'</programlisting>

    <para>Seu ojeto jQuery típico conterá referências para qualquer número de 
    elementos DOM, e esse é o porquê que objetos jQuery são geralmente 
    referenciados à coleções.</para>

    <para>Então, para fazer algo com uma coleção, nós precisamos iterar sobre 
    ela, que é mais facilmente feito utilizando o método <code>each()</code>
    do jQuery:</para>

    <programlisting>$.fn.myNewPlugin = function() {
    return this.each(function(){
    
    });
};</programlisting>

    <para>O método <code>each()</code> do jQuery, assim como a maioria dos
    outros métodos, retornam um objeto jQuery, permitindo-nos assim que 
    possamos saber e adorar o 'encadeamento' (<code>$(...).css().attr()...</code>).
    Nós não gostaríamos de quebrar esta convenção, então nós retornamos o objeto
    <code>this</code>. Neste loop, você poder fazer o que você quiser com cada
    elemento. Este é um exemplo de um pequeno plugin utilizando uma das técnicas
    que nós discutimos:</para>

    <programlisting>(function($){
    $.fn.showLinkLocation = function() {
        return this.filter('a').each(function(){
            $(this).append(
                ' (' + $(this).attr('href') + ')'
            );
        });
    };
}(jQuery));
    
// Exemplo de uso:
$('a').showLinkLocation();</programlisting>

    <para>Este prático plugin atravessa todas as âncoras na coleção e 
    anexa o atributo <code>href</code> entre parênteses.</para>

    <programlisting>&lt;!-- antes do plugin ser chamado: --&gt;
&lt;a href="page.html"&gt;Foo&lt;/a&gt;
    
&lt;!-- Depois que o plugin foi chamado: --&gt;
&lt;a href="page.html"&gt;Foo (page.html)&lt;/a&gt;</programlisting>

    <para>Nosso plugin pode ser otimizado:</para>

    <programlisting>(function($){
    $.fn.showLinkLocation = function() {
        return this.filter('a').append(function(){
              return ' (' + this.href + ')';
        });
    };
}(jQuery));</programlisting>

    <para>Nós estamos utilizando a capacidade de aceitação de um callback do 
    método <code>append</code>, e o valor de retorno deste callback irá determinar
    o que será aplicado a cada elemento na coleção. Perceba também que nós não
    estamos usando o método <code>attr</code> para obter o atributo <code>href</code>,
    pois a API do DOM nativa nos dá um acesso facilitado através da propriedade
    <code>href</code>.</para>

    <para>Este é um outro exemplo de plugin. Este não requer que nós façamos
    uma iteração sobre todos os elementos com o método <code>each()</code>.,
    Ao invés disso, não simplesmente vamos delegar para outros método do jQUery
    diretamente:</para>

    <programlisting>(function($){
    $.fn.fadeInAndAddClass = function(duration, className) {
        return this.fadeIn(duration, function(){
            $(this).addClass(className);
        });
    };
}(jQuery));
    
// Exemplo de uso:
$('a').fadeInAndAddClass(400, 'finishedFading');</programlisting>
  </section>

  <section>
    <title>Procurando &amp; Avaliando Plugins</title>

    <para>Os plugins extendem funcionalidades básicas do jQuery, e um dos 
    aspectos mais celebrados da biblioteca é seu extensivo ecossistema de 
    plugins. De ordenação de tabelas à validação de formulário e autocompletamento
    ... se há uma necessidade para algo, há boas chances que alguem já tenha
    escrito um plugin para isso.</para>

    <para>A qualidade dos plugins do jQuery varia muito. Muitos plugins são
    extensivamente testados e bem mantidos, mas outros são porcamente criados
    e então ignorados. Mais do que algumas falhas para seguir as melhores 
    práticas.</para>

    <para>O Google é seu melhor recurso inicial para localização de plugins,
    embora o time do jQuery esteja trabalhando em um repositório de plugin
    melhorado. Uma vez que você identificou  algumas opções através de uma
    busca do Google, você pode querer consultar a lista de emails do jQuery
    ou o canal de IRC #jquery para obter informações de outros.</para>

    <para>Quando estiver procurando por um plugin para preencher uma necessidade,
    faça seu trabalho de casa. Tenha certeza que o plugin é bem documentado, e 
    veja se o autor provê vários exemplos do seu uso. Tenha cuidado com plugins
    que fazem muito mais do que você precisa; eles podem acabar adicionando um
    overhead substancial à sua página. Para mais dicas sobre como identificar 
    um plugin ruim, leia <link
    xlink:href="http://remysharp.com/2010/06/03/signs-of-a-poorly-written-jquery-plugin/">Signs
    of a poorly written jQuery plugin</link> do Remy Sharp.</para>

    <para>Uma vez que você escolhe um plugin, você precisará adiciona-lo à
    sua página. Baixe o plugin, descompacte-o se necessário, coloque-o no
    diretório da sua aplicação e então inclua o plugin na sua página usando
    uma tag script (depois que você incluir o jQuery).</para>
  </section>

  <section>
    <title>Escrevendo Plugins</title>

    <para>Algumas vezes você quer que uma pequena funcionalidade esteja 
    disponível pelo seu código; por exemplo, tavez você queira que um simples
    método possa ser chamado para executar uma série de operações sobre uma 
    seleção do jQuery. Neste caso, você pode querer escrever um plugin.</para>

    <para>A maioria dos plugins do jQuery são simplesmente métodos criados no
    namespace <code>$.fn</code>. O jQuery garante que um método chamado num 
    objeto jQuery possa acessar aquele objeto jQuery como <code>this</code> 
    dentro do método. Em retorno, seu plugin precisa garantir que ele retorna
    o mesmo objeto que ele recebeu, a menos que o contrário seja explicitamente
    documentado.</para>

    <para>Este é um exemplo de um plugin simples:</para>

    <example>
      <title>Criando um plugin para adicionar e remover uma classe no hover</title>

      <programlisting>// definindo o plugin
(function($){
    $.fn.hoverClass = function(c) {
        return this.hover(
            function() { $(this).toggleClass(c); }
        );
    };
}(jQuery);

// utilizando o plugin
$('li').hoverClass('hover');</programlisting>
    </example>

    <para>Para mais sobre desenvolvimento de plugins, leia o post essencial do
    Mike Alsup's,
    <link
    xlink:href="http://www.learningjquery.com/2007/10/a-plugin-development-pattern">A
    Plugin Development Pattern</link>. Nele, ele cria um plugin chamado
    <code>$.fn.hilight</code>, que provê suporte para o plugin de metadados 
    se ele estiver presente e provê um método centralizado para configuração
    central e opções de instância para o plugin.</para>

    <example>
      <title>O Padrão de Desenvolvimento de Plugins do Mike Alsup</title>

      <programlisting>//
// cria a closure
//
(function($) {
  //
  // definição do plugin
  //
  $.fn.hilight = function(options) {
    debug(this);
    // constrói as opções principais antes da iteração com elemento
    var opts = $.extend({}, $.fn.hilight.defaults, options);
    // itera e reformata cada elemento encontrado
    return this.each(function() {
      $this = $(this);
      // constrói opções específicas do elemento
      var o = $.meta ? $.extend({}, opts, $this.data()) : opts;
      // atualiza estilos do elemento
      $this.css({
        backgroundColor: o.background,
        color: o.foreground
      });
      var markup = $this.html();
      // chama nossa função de formatação
      markup = $.fn.hilight.format(markup);
      $this.html(markup);
    });
  };
  //
  // função privada para debugging
  //
  function debug($obj) {
    if (window.console &amp;&amp; window.console.log)
      window.console.log('hilight selection count: ' + $obj.size());
  };
  //
  // define e expõe nossa função de formatação
  //
  $.fn.hilight.format = function(txt) {
    return '&lt;strong&gt;' + txt + '&lt;/strong&gt;';
  };
  //
  // padrões do plugin
  //
  $.fn.hilight.defaults = {
    foreground: 'red',
    background: 'yellow'
  };
//
// fim da closure
//
})(jQuery);</programlisting>
    </example>
  </section>

  <section>
    <title>Writing Stateful Plugins with the jQuery UI Widget Factory</title>

    <para>
      <note>
        <para>This section is based, with permission, on the blog post <link
        xlink:href="http://blog.nemikor.com/2010/05/15/building-stateful-jquery-plugins/">Building
        Stateful jQuery Plugins</link> by Scott Gonzalez.</para>
      </note>While most existing jQuery plugins are stateless — that is, we
    call them on an element and that is the extent of our interaction with the
    plugin — there’s a large set of functionality that doesn’t fit into the
    basic plugin pattern.</para>

    <para>In order to fill this gap, jQuery UI has implemented a more advanced
    plugin system. The new system manages state, allows multiple functions to
    be exposed via a single plugin, and provides various extension points.
    This system is called the widget factory and is exposed as
    <code>jQuery.widget</code> as part of jQuery UI 1.8; however, it can be
    used independently of jQuery UI. </para>

    <para>To demonstrate the capabilities of the widget factory, we'll build a
    simple progress bar plugin. </para>

    <para>To start, we’ll create a progress bar that just lets us set the
    progress once. As we can see below, this is done by calling
    <code>jQuery.widget</code> with two parameters: the name of the plugin to
    create and an object literal containing functions to support our plugin.
    When our plugin gets called, it will create a new plugin instance and all
    functions will be executed within the context of that instance. This is
    different from a standard jQuery plugin in two important ways. First, the
    context is an object, not a DOM element. Second, the context is always a
    single object, never a collection. </para>

    <example>
      <title>A simple, stateful plugin using the jQuery UI widget
      factory</title>

      <programlisting>$.widget("nmk.progressbar", {
    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass("progressbar")
            .text(progress);
    }
});</programlisting>
    </example>

    <para>The name of the plugin must contain a namespace; in this case we’ve
    used the <code>nmk</code> namespace. There is a limitation that namespaces
    be exactly one level deep — that is, we can't use a namespace like
    <code>nmk.foo</code>. We can also see that the widget factory has provided
    two properties for us. <code>this.element</code> is a jQuery object
    containing exactly one element. If our plugin is called on a jQuery object
    containing multiple elements, a separate plugin instance will be created
    for each element, and each instance will have its own
    <code>this.element</code>. The second property, <code>this.options</code>,
    is a hash containing key/value pairs for all of our plugin’s options.
    These options can be passed to our plugin as shown here. </para>

    <note>
      <para>In our example we use the <code>nmk</code> namespace. The
      <code>ui</code> namespace is reserved for official jQuery UI plugins.
      When building your own plugins, you should create your own namespace.
      This makes it clear where the plugin came from and whether it is part of
      a larger collection.</para>
    </note>

    <example>
      <title>Passing options to a widget</title>

      <programlisting>$("&lt;div&gt;&lt;/div&gt;")
    .appendTo( "body" )
    .progressbar({ value: 20 });</programlisting>
    </example>

    <para>When we call <code>jQuery.widget</code> it extends jQuery by adding
    a method to <code>jQuery.fn</code> (the same way we'd create a standard
    plugin). The name of the function it adds is based on the name you pass to
    <code>jQuery.widget</code>, without the namespace; in our case it will
    create <code>jQuery.fn.progressbar</code>. The options passed to our
    plugin get set in <code>this.options</code> inside of our plugin instance.
    As shown below, we can specify default values for any of our options. When
    designing your API, you should figure out the most common use case for
    your plugin so that you can set appropriate default values and make all
    options truly optional. </para>

    <example>
      <title>Setting default options for a widget</title>

      <programlisting>$.widget("nmk.progressbar", {
    // default options
    options: {
        value: 0
    },

    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass( "progressbar" )
            .text( progress );
    }
});</programlisting>
    </example>

    <section>
      <title>Adding Methods to a Widget</title>

      <para>Now that we can initialize our progress bar, we’ll add the ability
      to perform actions by calling methods on our plugin instance. To define
      a plugin method, we just include the function in the object literal that
      we pass to <code>jQuery.widget</code>. We can also define “private”
      methods by prepending an underscore to the function name. </para>

      <example>
        <title>Creating widget methods</title>

        <programlisting>$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass("progressbar")
            .text(progress);
    },

    // create a public method
    value: function(value) {
        // no value passed, act as a getter
        if (value === undefined) {
            return this.options.value;
        // value passed, act as a setter
        } else {
            this.options.value = this._constrain(value);
            var progress = this.options.value + "%";
            this.element.text(progress);
        }
    },

    // create a private method
    _constrain: function(value) {
        if (value &gt; 100) {
            value = 100;
        }
        if (value &lt; 0) {
            value = 0;
        }
        return value;
    }
});
</programlisting>
      </example>

      <para>To call a method on a plugin instance, you pass the name of the
      method to the jQuery plugin. If you are calling a method that accepts
      parameters, you simply pass those parameters after the method name.
      </para>

      <example>
        <title>Calling methods on a plugin instance</title>

        <programlisting>var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar({ value: 20 });

// get the current value
alert(bar.progressbar("value"));

// update the value
bar.progressbar("value", 50);

// get the current value again
alert(bar.progressbar("value"));</programlisting>
      </example>

      <note>
        <para>Executing methods by passing the method name to the same jQuery
        function that was used to initialize the plugin may seem odd. This is
        done to prevent pollution of the jQuery namespace while maintaining
        the ability to chain method calls. </para>
      </note>
    </section>

    <section>
      <title>Working with Widget Options</title>

      <para>One of the methods that is automatically available to our plugin
      is the <code>option</code> method. The option method allows you to get
      and set options after initialization. This method works exactly like
      jQuery’s css and attr methods: you can pass just a name to use it as a
      setter, a name and value to use it as a single setter, or a hash of
      name/value pairs to set multiple values. When used as a getter, the
      plugin will return the current value of the option that corresponds to
      the name that was passed in. When used as a setter, the plugin’s
      <code>_setOption</code> method will be called for each option that is
      being set. We can specify a <code>_setOption</code> method in our plugin
      to react to option changes. </para>

      <example>
        <title>Responding when an option is set</title>

        <programlisting>$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
    }
});</programlisting>
      </example>
    </section>

    <section>
      <title>Adding Callbacks</title>

      <para>One of the easiest ways to make your plugin extensible is to add
      callbacks so users can react when the state of your plugin changes. We
      can see below how to add a callback to our progress bar to signify when
      the progress has reached 100%. The <code>_trigger</code> method takes
      three parameters: the name of the callback, a native event object that
      initiated the callback, and a hash of data relevant to the event. The
      callback name is the only required parameter, but the others can be very
      useful for users who want to implement custom functionality on top of
      your plugin. For example, if we were building a draggable plugin, we
      could pass the native mousemove event when triggering a drag callback;
      this would allow users to react to the drag based on the x/y coordinates
      provided by the event object. </para>

      <example>
        <title>Providing callbacks for user extension</title>

        <programlisting>$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
        if (this.options.value == 100) {
            this._trigger("complete", null, { value: 100 });
        }
    }
});</programlisting>
      </example>

      <para>Callback functions are essentially just additional options, so you
      can get and set them just like any other option. Whenever a callback is
      executed, a corresponding event is triggered as well. The event type is
      determined by concatenating the plugin name and the callback name. The
      callback and event both receive the same two parameters: an event object
      and a hash of data relevant to the event, as we’ll see below. </para>

      <para>If your plugin has functionality that you want to allow the user
      to prevent, the best way to support this is by creating cancelable
      callbacks. Users can cancel a callback, or its associated event, the
      same way they cancel any native event: by calling
      <code>event.preventDefault()</code> or using <code>return false</code>.
      If the user cancels the callback, the <code>_trigger</code> method will
      return false so you can implement the appropriate functionality within
      your plugin. </para>

      <example>
        <title>Binding to widget events</title>

        <programlisting>var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar({
        complete: function(event, data) {
            alert( "Callbacks are great!" );
        }
    })
    .bind("progressbarcomplete", function(event, data) {
        alert("Events bubble and support many handlers for extreme flexibility.");
        alert("The progress bar value is " + data.value);
    });

bar.progressbar("option", "value", 100);</programlisting>
      </example>

      <sidebar>
        <title>The Widget Factory: Under the Hood</title>

        <para>When you call <code>jQuery.widget</code>, it creates a
        constructor function for your plugin and sets the object literal that
        you pass in as the prototype for your plugin instances. All of the
        functionality that automatically gets added to your plugin comes from
        a base widget prototype, which is defined as
        <code>jQuery.Widget.prototype</code>. When a plugin instance is
        created, it is stored on the original DOM element using
        <code>jQuery.data</code>, with the plugin name as the key.</para>

        <para>Because the plugin instance is directly linked to the DOM
        element, you can access the plugin instance directly instead of going
        through the exposed plugin method if you want. This will allow you to
        call methods directly on the plugin instance instead of passing method
        names as strings and will also give you direct access to the plugin’s
        properties. </para>

        <programlisting>var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar()
    .data("progressbar" );

// call a method directly on the plugin instance
bar.option("value", 50);

// access properties on the plugin instance
alert(bar.options.value);</programlisting>

        <para>One of the biggest benefits of having a constructor and
        prototype for a plugin is the ease of extending the plugin. By adding
        or modifying methods on the plugin’s prototype, we can modify the
        behavior of all instances of our plugin. For example, if we wanted to
        add a method to our progress bar to reset the progress to 0% we could
        add this method to the prototype and it would instantly be available
        to be called on any plugin instance. </para>

        <programlisting>$.nmk.progressbar.prototype.reset = function() {
    this._setOption("value", 0);
};</programlisting>
      </sidebar>
    </section>

    <section>
      <title>Cleaning Up</title>

      <para>In some cases, it will make sense to allow users to apply and then
      later unapply your plugin. You can accomplish this via the destroy
      method. Within the <code>destroy</code> method, you should undo anything
      your plugin may have done during initialization or later use. The
      <code>destroy</code> method is automatically called if the element that
      your plugin instance is tied to is removed from the DOM, so this can be
      used for garbage collection as well. The default <code>destroy</code>
      method removes the link between the DOM element and the plugin instance,
      so it’s important to call the base function from your plugin’s
      <code>destroy</code> method. </para>

      <example>
        <title>Adding a destroy method to a widget</title>

        <programlisting>$.widget( "nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
        if (this.options.value == 100 ) {
            this._trigger("complete", null, { value: 100 });
        }
    },

    destroy: function() {
        this.element
            .removeClass("progressbar")
            .text("");

        // call the base destroy function
        $.Widget.prototype.destroy.call(this);
    }
});</programlisting>
      </example>
    </section>

    <section>
      <title>Conclusion</title>

      <para>The widget factory is only one way of creating stateful plugins.
      There are a few different models that can be used and each have their
      own advantages and disadvantages. The widget factory solves lots of
      common problems for you and can greatly improve productivity, it also
      greatly improves code reuse, making it a great fit for jQuery UI as well
      as many other stateful plugins. </para>
    </section>
  </section>

  <section>
    <title>Exercises</title>

    <xi:include href="exercises/sortable-plugin.xml" xpointer="element(/1)" />

    <xi:include href="exercises/striping-plugin.xml" xpointer="element(/1)" />
  </section>
</chapter>
