<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Eventos Customizados</title>

  <section>
    <title>Introduzindo Eventos Customizados</title>

    <para>Nós todos estamos familiares com eventos básicos - click, mouseover,
    focus, blur, submit, etc. - estes que nós podemos usar para interações
    entre o usuário e o navegador. Eventos customizados abrem um mundo 
    completamente novo de programação orientada a eventos. Neste capítulo,
    nós iremos utilizar o sistema de eventos customizados do jQuery para fazer
    uma aplicação de busca simples no Twitter.</para>

    <para>Pode ser difícil à primeira instância entender por que você iria
    querer utilizar eventos customizados, quando os eventos já prontos parecem
    satisfazer bem suas necessidades. Acontece que eventos customizados oferecem
    um jeito completamente novo de pensar sobre JavaScript orientado a eventos.
    Ao invés de focar no elemento que dispara uma ação, eventos customizados
    colocam o holoforte  no elemento em ação. Isso traz muitos benefícios,
    incluindo:</para>

    <itemizedlist>
      <listitem>
        <para>Comportamentos do elemento alvo podem ser facilmente disparados
        por elementos diferentes utilizando o mesmo código.</para>
      </listitem>

      <listitem>
        <para>Comportamentos podem ser disparados através de elementos-alvo
        múltiplos e similares de uma vez.</para>
      </listitem>

      <listitem>
        <para>Comportamentos podem ser mais facilmente associados com o elemento
        alvo no código, tornando o código mais fácil de ler e manter.</para>
      </listitem>
    </itemizedlist>

    <para>Por que você deveria se importar? Um exemplo é provavelmente a melhor
    forma de explicar. Suponha que você tenha uma lâmpada num quarto na casa. A
    lâmpada está ligada e ela é controlada por dois switches de três vias e um
    clapper:</para>

    <programlisting>&lt;div class="room" id="kitchen"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;</programlisting>

    <para>O estado da lâmpada irá mudar disparando o clapper ou mesmo os 
    switches. Os switches e o clapper não se importam em qual estado a lâmpada
    está; eles somente querem mudar o estado.</para>

    <para>Sem eventos customizados, você talvez poderia escrever algo assim: </para>

    <programlisting>$('.switch, .clapper').click(function() {
    var $light = $(this).parent().find('.lightbulb');
    if ($light.hasClass('on')) {
        $light.removeClass('on').addClass('off');
    } else {
        $light.removeClass('off').addClass('on');
    }
});</programlisting>

    <para>Com eventos customizados, seu código pode ficar parecido com este: </para>

    <programlisting>$('.lightbulb').bind('changeState', function(e) {
    var $light = $(this);
    if ($light.hasClass('on')) {
        $light.removeClass('on').addClass('off');
    } else {
        $light.removeClass('off').addClass('on');
    }
});

$('.switch, .clapper').click(function() { 
    $(this).parent().find('.lightbulb').trigger('changeState');
});</programlisting>

    <para>Este último pedaço de código não é lá essas coisas, mas algo importante
    aconteceu: nós movemos o comportamento da lâmpada para a lâmpada, e ficamos
    longe dos switches e do clapper. </para>

    <para>Vamos tornar nosso exemplo um pouco mais interessante. Nós vamos 
    adicionar outro quarto à nossa casa, junto com o switch mestre, como
    mostrado a seguir: </para>

    <programlisting>&lt;div class="room" id="kitchen"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="room" id="bedroom"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="master_switch"&gt;&lt;/div&gt;</programlisting>

    <para>Se há várias luzes na casa, nós queremos que o switch mestre desligue
    todas as luzes; de outra forma, nós queremos todas as luzes acesas. Para
    fazer isso, nós iremos adicionar dois ou mais eventos customizados às
    lâmpadas: <code>turnOn</code> e <code>turnOff</code>. Nós iremos fazer uso
    deles no evento customizado <code>changeState</code>, e usar alguma lógica
    para decidir qual que o switch mestre vai disparar:</para>

    <programlisting>$('.lightbulb')
    .bind('changeState', function(e) {
        var $light = $(this);
        if ($light.hasClass('on')) {
            $light.trigger('turnOff');
        } else {
            $light.trigger('turnOn');
        }
    })
    .bind('turnOn', function(e) {
        $(this).removeClass('off').addClass('on');
    })
    .bind('turnOff', function(e) {
        $(this).removeClass('off').addClass('on');
    });
 
$('.switch, .clapper').click(function() { 
    $(this).parent().find('.lightbulb').trigger('changeState');
});
 
$('#master_switch').click(function() {
    if ($('.lightbulb.on').length) {
        $('.lightbulb').trigger('turnOff');
    } else {
        $('.lightbulb').trigger('turnOn');
    }
});</programlisting>

    <para>Note como o comportamento do switch mestre está vinculado ao switch 
    mestre; O comportamento de uma lâmpada pertence às lâmpadas.</para>

    <note>
      <para>Se você está acostumado com programação orientada a objetos,
      talvez seja útil pensar em evetos como se fossem métodos de objetos.
      Grosseiramente falando, o objeto que o método pertence é criado pelo
      seletor do jQuery. Vinculando o evento customizado changeState para
      todos os elementos <code>$(‘.light’)</code> é similar a ter uma classe
      chamada <code>Light</code> com um método <code>changeState</code>, e 
      então instanciamos novos objetos <code>Light</code> para cada elemento
      com o nome de classe light.</para>
    </note>

    <sidebar>
      <title>Recapitulando: $.fn.bind e $.fn.trigger</title>

      <para>No mundo dos eventos customizados, há dois métodos importantes do
      jQuery: <code>$.fn.bind</code> e <code>$.fn.trigger</code>. No capítulo
      Eventos, nós vimos como usar estes métodos para trabalhar com eventos
      do usuário; neste capítulo, é importante relemebrar duas coisas:</para>

      <itemizedlist>
        <listitem>
          <para>O método <code>$.fn.bind</code> recebe o tipo do evento e
          uma função manipuladora do mesmo como argumentos. Opcionalmente, ele
          pode também receber dados relacionados ao eventos como seu segundo
          argumento, passando a função manipuladora do evento para o terceiro
          argumento. Qualquer dado que é passado será disponível para a função
          manipuladora do evento na propriedade <code>data</code> do objeto do
          evento. A função manipuladora do evento sempre recebe o objeto do 
          evento como seu primeiro argumento.</para>
        </listitem>

        <listitem>
          <para>O método <code>$.fn.trigger</code> recebe um tipo de evento como
          argumento. Opcionalmente, ele também pode receber um arrayt de valores.
          Estes valores serão passados para a função manipuladora de eventos como
          argumentos depois do objeto de evento.</para>
        </listitem>
      </itemizedlist>

      <para>Here is an example of the usage of <code>$.fn.bind</code> and
      <code>$.fn.trigger</code> that uses custom data in both cases:</para>

      <programlisting>$(document).bind('myCustomEvent', { foo : 'bar' }, function(e, arg1, arg2) {
    console.log(e.data.foo); // 'bar'
    console.log(arg1); // 'bim'
    console.log(arg2); // 'baz'
});

$(document).trigger('myCustomEvent', [ 'bim', 'baz' ]);</programlisting>
    </sidebar>

    <section>
      <title>A Sample Application</title>

      <para>To demonstrate the power of custom events, we’re going to create a
      simple tool for searching Twitter. The tool will offer several ways for
      a user to add search terms to the display: by entering a search term in
      a text box, by entering multiple search terms in the URL, and by
      querying Twitter for trending terms. </para>

      <para>The results for each term will be shown in a results container;
      these containers will be able to be expanded, collapsed, refreshed, and
      removed, either individually or all at once. </para>

      <para>When we’re done, it will look like this: </para>

      <figure>
        <title>Our finished application</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="http://gyazo.com/70415e9fffab1c47953f5264ecf722fe.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <section>
        <title>The Setup</title>

        <para>We’ll start with some basic HTML: </para>

        <programlisting>&lt;h1&gt;Twitter Search&lt;/h1&gt;
&lt;input type="button" id="get_trends" 
    value="Load Trending Terms" /&gt;
 
&lt;form&gt;
    &lt;input type="text" class="input_text" 
        id="search_term" /&gt;
    &lt;input type="submit" class="input_submit" 
        value="Add Search Term" /&gt;
&lt;/form&gt;
 
&lt;div id="twitter"&gt;
    &lt;div class="template results"&gt;
        &lt;h2&gt;Search Results for 
        &lt;span class="search_term"&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/div&gt;</programlisting>

        <para>This gives us a container (#twitter) for our widget, a template
        for our results containers (hidden via CSS), and a simple form where
        users can input a search term. (For the sake of simplicity, we’re
        going to assume that our application is JavaScript-only and that our
        users will always have CSS.)</para>

        <para>There are two types of objects we’ll want to act on: the results
        containers, and the Twitter container.</para>

        <para>The results containers are the heart of the application. We’ll
        create a plugin that will prepare each results container once it’s
        added to the Twitter container. Among other things, it will bind the
        custom events for each container and add the action buttons at the top
        right of each container. Each results container will have the
        following custom events: </para>

        <variablelist>
          <varlistentry>
            <term>refresh</term>

            <listitem>
              <para>Mark the container as being in the “refreshing” state, and
              fire the request to fetch the data for the search term.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>populate</term>

            <listitem>
              <para>Receive the returned JSON data and use it to populate the
              container.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>remove</term>

            <listitem>
              <para>Remove the container from the page after the user verifies
              the request to do so. Verification can be bypassed by passing
              true as the second argument to the event handler. The remove
              event also removes the term associated with the results
              container from the global object containing the search
              terms.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>collapse</term>

            <listitem>
              <para>Add a class of collapsed to the container, which will hide
              the results via CSS. It will also turn the container’s
              “Collapse” button into an “Expand” button.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>expand</term>

            <listitem>
              <para>Remove the collapsed class from the container. It will
              also turn the container’s “Expand” button into a “Collapse”
              button.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The plugin is also responsible for adding the action buttons to
        the container. It binds a click event to each action’s list item, and
        uses the list item’s class to determine which custom event will be
        triggered on the corresponding results container. </para>

        <programlisting>$.fn.twitterResult = function(settings) {
    return $(this).each(function() {
        var $results = $(this),
            $actions = $.fn.twitterResult.actions = 
                $.fn.twitterResult.actions || 
                $.fn.twitterResult.createActions(),
            $a = $actions.clone().prependTo($results),
            term = settings.term;

        $results.find('span.search_term').text(term);

        $.each(
            ['refresh', 'populate', 'remove', 'collapse', 'expand'], 
            function(i, ev) { 
                $results.bind(
                    ev, 
                    { term : term },
                    $.fn.twitterResult.events[ev]
                ); 
            }
        );

        // use the class of each action to figure out 
        // which event it will trigger on the results panel
        $a.find('li').click(function() {
            // pass the li that was clicked to the function
            // so it can be manipulated if needed
            $results.trigger($(this).attr('class'), [ $(this) ]);
        });
    });
};

$.fn.twitterResult.createActions = function() {
    return $('&lt;ul class="actions" /&gt;').append(
        '&lt;li class="refresh"&gt;Refresh&lt;/li&gt;' +
        '&lt;li class="remove"&gt;Remove&lt;/li&gt;' +
        '&lt;li class="collapse"&gt;Collapse&lt;/li&gt;'
    );
};

$.fn.twitterResult.events = {
    refresh : function(e) {
           // indicate that the results are refreshing
        var $this = $(this).addClass('refreshing');

        $this.find('p.tweet').remove();
        $results.append('&lt;p class="loading"&gt;Loading ...&lt;/p&gt;');

        // get the twitter data using jsonp
        $.getJSON(
            'http://search.twitter.com/search.json?q=' +                     
                escape(e.data.term) + '&amp;rpp=5&amp;callback=?', 
            function(json) { 
                $this.trigger('populate', [ json ]); 
            }
        );
    },

    populate : function(e, json) {
        var results = json.results;
        var $this = $(this);

        $this.find('p.loading').remove();

        $.each(results, function(i,result) {
            var tweet = '&lt;p class="tweet"&gt;' + 
                '&lt;a href="http://twitter.com/' + 
                result.from_user + 
                '"&gt;' +
                result.from_user + 
                '&lt;/a&gt;: ' +
                result.text + 
                ' &lt;span class="date"&gt;' + 
                result.created_at + 
                '&lt;/span&gt;' +
            '&lt;/p&gt;';
            $this.append(tweet);
        });

        // indicate that the results 
        // are done refreshing
        $this.removeClass('refreshing');
    },

    remove : function(e, force) {
        if (
            !force &amp;&amp;     
            !confirm('Remove panel for term ' + e.data.term + '?')
        ) {
            return;
        }
        $(this).remove();

        // indicate that we no longer 
        // have a panel for the term
        search_terms[e.data.term] = 0;
    },

    collapse : function(e) {
        $(this).find('li.collapse').removeClass('collapse')
            .addClass('expand').text('Expand');

        $(this).addClass('collapsed');
    },

    expand : function(e) {
        $(this).find('li.expand').removeClass('expand')
            .addClass('collapse').text('Collapse');

        $(this).removeClass('collapsed');
    }
};</programlisting>

        <para>The Twitter container itself will have just two custom events:
        </para>

        <variablelist>
          <varlistentry>
            <term>getResults</term>

            <listitem>
              <para>Receives a search term and checks to determine whether
              there’s already a results container for the term; if not, adds a
              results container using the results template, set up the results
              container using the <code>$.fn.twitterResult</code> plugin
              discussed above, and then triggers the <code>refresh</code>
              event on the results container in order to actually load the
              results. Finally, it will store the search term so the
              application knows not to re-fetch the term.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>getTrends</term>

            <listitem>
              <para>Queries Twitter for the top 10 trending terms, then
              iterates over them and triggers the <code>getResults</code>
              event for each of them, thereby adding a results container for
              each term. </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Here's how the Twitter container bindings look:</para>

        <programlisting>$('#twitter')
    .bind('getResults', function(e, term) {
        // make sure we don't have a box for this term already
        if (!search_terms[term]) { 
            var $this = $(this);
            var $template = $this.find('div.template');

            // make a copy of the template div
            // and insert it as the first results box
            $results = $template.clone().
                removeClass('template').
                insertBefore($this.find('div:first')).
                twitterResult({
                    'term' : term
                });

            // load the content using the "refresh" 
            // custom event that we bound to the results container
            $results.trigger('refresh');
            search_terms[term] = 1;
        }
    })
    .bind('getTrends', function(e) {
        var $this = $(this);
        $.getJSON('http://search.twitter.com/trends.json?callback=?', function(json) {
                var trends = json.trends; 
                $.each(trends, function(i, trend) {
                    $this.trigger('getResults', [ trend.name ]);
                });
            });
    });</programlisting>

        <para>So far, we’ve written a lot of code that does approximately
        nothing, but that’s OK. By specifying all the behaviors that we want
        our core objects to have, we’ve created a solid framework for rapidly
        building out the interface. </para>

        <para>Let’s start by hooking up our text input and the “Load Trending
        Terms” button. For the text input, we’ll capture the term that was
        entered in the input and pass it as we trigger the Twitter container’s
        <code>getResults</code> event. Clicking the “Load Trending Terms” will
        trigger the Twitter container’s <code>getTrends</code> event: </para>

        <programlisting>$('form').submit(function(e) {
    e.preventDefault();
    var term = $('#search_term').val();
    $('#twitter').trigger('getResults', [ term ]);
});

$('#get_trends').click(function() {
    $('#twitter').trigger('getTrends'); 
});</programlisting>

        <para>By adding a few buttons with the appropriate IDs, we can make it
        possible to remove, collapse, expand, and refresh all results
        containers at once, as shown below. For the remove button, note how
        we’re passing a value of true to the event handler as its second
        argument, telling the event handler that we don’t want to verify the
        removal of individual containers. </para>

        <programlisting>$.each(['refresh', 'expand', 'collapse'], function(i, ev) {
    $('#' + ev).click(function(e) { $('#twitter div.results').trigger(ev); });
});

$('#remove').click(function(e) {
    if (confirm('Remove all results?')) {
        $('#twitter div.results').trigger('remove', [ true ]);
    }
});</programlisting>
      </section>

      <section>
        <title>Conclusion</title>

        <para>Custom events offer a new way of thinking about your code: they
        put the emphasis on the target of a behavior, not on the element that
        triggers it. If you take the time at the outset to spell out the
        pieces of your application, as well as the behaviors those pieces need
        to exhibit, custom events can provide a powerful way for you to “talk”
        to those pieces, either one at a time or en masse. Once the behaviors
        of a piece have been described, it becomes trivial to trigger those
        behaviors from anywhere, allowing for rapid creation of and
        experimentation with interface options. Finally, custom events can
        enhance code readability and maintainability, by making clear the
        relationship between an element and its behaviors. </para>

        <para>You can see the full application at
        <filename>demos/custom-events.html</filename> and
        <filename>demos/js/custom-events.js</filename> in the sample
        code.</para>
      </section>
    </section>
  </section>
</chapter>
